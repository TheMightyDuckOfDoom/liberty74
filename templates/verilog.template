// Copyright 2024 Tobias Senti
// Solderpad Hardware License, Version 0.51, see LICENSE for details.
// SPDX-License-Identifier: SHL-0.51

/* ${stamp} */

% for cell in cells:
  % if 'custom_verilog_model' in cell and cell['custom_verilog_model']:
    <% break %>
  % endif

// ${cell['desc']}
module ${cell['name']} (
  % if 'power' in cell:
    `ifdef PWR_PINS
    % for idx, power_pin in enumerate(cell['unique_power']):
    input  logic ${power_pin['name']}\
      % if idx < len(cell['power']) - 1 or 'inputs' in cell or 'inouts' in cell or 'outputs' in cell:
,
      % else:

      % endif
    % endfor
    `endif
  % endif
  % if 'inputs' in cell:
    % for idx, input in enumerate(cell['inputs']):
      % if 'bus_name' in input:
    input  logic [${bus_types[input['bus_type']]['from']}:${bus_types[input['bus_type']]['to']}] ${input['bus_name']}\
      % else:
    input  logic ${input['name']}\
      % endif
      % if idx < len(cell['inputs']) - 1 or ('inouts' in cell and len(cell['inouts']) > 0) or ('outputs' in cell and len(cell['outputs']) > 0):
,
      % else:

      % endif
    % endfor
  % endif
  % if 'inouts' in cell:
    % for idx, inout in enumerate(cell['inouts']):
      % if 'bus_name' in inout:
    inout  logic [${bus_types[inout['bus_type']]['from']}:${bus_types[inout['bus_type']]['to']}] ${inout['bus_name']}\
      % else:
    inout  logic ${output['name']}\
      % endif
      % if idx < len(cell['inouts']) - 1 or ('outputs' in cell and len(cell['outputs']) > 0):
,
      % else:

      % endif
    % endfor
  % endif
  % if 'outputs' in cell:
    % for idx, output in enumerate(cell['outputs']):
      % if 'bus_name' in output:
    output logic [${bus_types[output['bus_type']]['from']}:${bus_types[output['bus_type']]['to']}] ${output['bus_name']}\
      % else:
    output logic ${output['name']}\
      % endif
      % if idx < len(cell['outputs']) - 1:
,
      % else:

      % endif
    % endfor
  % endif
);
% if 'memory' in cell:
    single_port_async_sram #(
        .ADDR_WIDTH ( ${cell['memory']['address_width']} ),
        .DATA_WIDTH ( ${cell['memory']['word_width']} )
    ) i_sram_model (
        .cs_i    ( ${cell['memory']['chip_select']} ),
        .we_i    ( ${cell['memory']['write_enable']} ),
        .oe_i    ( ${cell['memory']['output_enable']} ),
        .addr_i  ( ${cell['memory']['address']} ),
        .data_io ( ${cell['memory']['data']} )
    );

  % if 'outputs' in cell:
    % for output in cell['outputs']:
      % if 'verilog_function' in output:
    assign ${output['name']} = ${output['verilog_function']};
      % else:
    assign ${output['name']} = ${output['function']};
      % endif
    % endfor
  % endif
% elif 'outputs' in cell:
  % for output in cell['outputs']:
    % if output['function'].startswith('IQ'):
      % if 'latch' in cell:
        % if 'three_state_enable' in output:
    logic ${output['name']}_q;

    assign ${output['name']} = ${output['three_state_enable']} ? 1'bZ : ${output['name']}_q;

        % endif
    always_latch begin
        if (${cell['latch']['enable']})
        % if 'three_state_enable' in output:
            ${output['name']}_q = ${cell['latch']['data_in']};
        % else:
            ${output['name']} = ${cell['latch']['data_in']};
        % endif
      % elif 'ff' in cell:
    always_ff @(posedge ${cell['ff']['clocked_on']}\
        % if 'clear' in cell['ff']:
 or \
          % if '!' in cell['ff']['clear']:
negedge\
          % else:
posedge\
          % endif
 ${cell['ff']['clear'].replace('!', '')}) begin
        if (${cell['ff']['clear']})
            ${output['name']} <= '0;
        else
    \
        % else:
) begin
        % endif
        ${output['name']} <= ${cell['ff']['next_state']};
      % else:
        % if 'three_state_enable' in output:
    logic [${bus_types[output['bus_type']]['from']}:${bus_types[output['bus_type']]['to']}] ${output['bus_name']}_q;

    assign ${output['bus_name']}[${bus_types[output['bus_type']]['from']}:${bus_types[output['bus_type']]['to']}]\
 = ${output['three_state_enable']} ? 'Z : ${output['bus_name']}_q[${bus_types[output['bus_type']]['from']}:${bus_types[output['bus_type']]['to']}];
        % endif
<%
ff_bank = list(filter(lambda x: x['name'] == output['function'], cell['ff_banks']))[0]
%>
    always_ff @(posedge ${ff_bank['clocked_on']}\
        % if 'clear' in ff_bank:
 or \
          % if '!' in ff_bank['clear']:
negedge\
          % else:
posedge\
          % endif
 ${ff_bank['clear'].replace('!', '')}) begin
        if (${ff_bank['clear']})
        % if 'three_state_enable' in output:
        Q\
        % else:
        ${output['bus_name']}\
        % endif
[${bus_types[output['bus_type']]['from']}:${bus_types[output['bus_type']]['to']} <= '0;
        else
    \
        % else:
) begin
        % endif
        % if 'three_state_enable' in output:
        ${output['bus_name']}_q\
        % else:
        ${output['bus_name']}\
        % endif
[${bus_types[output['bus_type']]['from']}:${bus_types[output['bus_type']]['to']}]\
 <= ${ff_bank['next_state']}[${bus_types[output['bus_type']]['from']}:${bus_types[output['bus_type']]['to']}];
      % endif
    end
    % elif 'verilog_function' in output:
    assign ${output['name']} = ${output['verilog_function']};
    % else:
    assign ${output['name']} = ${output['function']};
    % endif

  % endfor
% endif
% if 'power' in cell:
  `ifdef PWR_PINS
    initial begin
    % for idx, power_pin in enumerate(cell['unique_power']):
      % if 'connect_to_net' in power_pin:
      assert(${power_pin['name']} == ${power_pin['connect_to_net']});
      % elif power_pin['function'] == 'power':
      assert(${power_pin['name']} == 1); 
      % else:
      assert(${power_pin['name']} == 1);
      % endif
    % endfor
    end
  `endif
  % endif
endmodule
% endfor
